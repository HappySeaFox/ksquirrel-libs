/*  This file is part of ksquirrel-libs (http://ksquirrel.sf.net)

    Copyright (c) 2004 Dmitry Baryshev <ksquirrel@tut.by>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation;
    either version 2 of the License, or (at your option) any later
    version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include "read_psd.h"

FILE *fptr;
int bytes, currentImage;
int width, height;
unsigned channel_count, compression;

const char* fmt_version()
{
    return (const char*)"0.1";
}

const char* fmt_quickinfo()
{
    return (const char*)"Adobe Photoshop PSD";
}

const char* fmt_filter()
{
    return (const char*)"*.psd ";
}

const char* fmt_mime()
{
/*  QRegExp pattern  */
    return (const char*)"\x0038\x0042\x0050\x0053";
}

const char* fmt_pixmap()
{
    return (const char*)"137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,4,3,0,0,0,237,221,226,82,0,0,0,21,80,76,84,69,112,0,25,192,192,192,255,255,255,0,0,0,255,255,0,128,128,0,4,4,4,204,13,117,30,0,0,0,1,116,82,78,83,0,64,230,216,102,0,0,0,83,73,68,65,84,120,218,61,142,65,17,192,48,8,4,177,192,7,1,88,200,85,1,56,104,5,180,159,248,151,80,114,161,221,215,206,13,28,136,200,92,72,241,168,170,81,220,221,102,75,69,163,17,36,9,193,184,78,4,74,138,40,86,18,160,32,59,65,198,193,153,111,235,239,217,205,110,125,148,87,249,198,253,2,11,129,25,221,25,73,23,33,0,0,0,0,73,69,78,68,174,66,96,130,130";
}

int fmt_init(fmt_info *finfo, const char *file)
{
    if(!finfo)
        return SQERR_NOMEMORY;
	
    fptr = fopen(file, "rb");

    if(!fptr)
        return SQERR_NOFILE;
	
    currentImage = -1;
    
    if(Read32(fptr) != 0x38425053)
	return SQERR_BADFILE;

    if(Read16(fptr) != 1)
	return SQERR_NOTSUPPORTED;

    return SQERR_OK;
}

int fmt_next(fmt_info *finfo)
{
    currentImage++;
    
    if(currentImage)
	return SQERR_NOTOK;

    if(!finfo->image)
	return SQERR_NOMEMORY;

    memset(&finfo->image[currentImage], 0, sizeof(fmt_image));
    
    char __dummy[6];
    fread(__dummy, 6, 1, fptr);

    finfo->image[currentImage].passes = 1;


    channel_count = Read16(fptr);

    if(channel_count > 16)
	return SQERR_NOTSUPPORTED;
	
    width = finfo->image[currentImage].h = Read32(fptr);
    height = finfo->image[currentImage].w = Read32(fptr);
    
    if(Read16(fptr) == 8)
    {
	unsigned mode = Read16(fptr);

	// Valid options are:
	//   0: Bitmap (not implemented)
	//   1: Grayscale (not implemented)
	//   2: Indexed color (not implemented)
	//   3: RGB color
	//   4: CMYK color (not implemented)
	//   7: Multichannel (not implemented)
	//   8: Duotone (not implemented)
	//   9: Lab color (not implemented)

	if(mode != 3)
	    return SQERR_NOTSUPPORTED;
	    
	printf("mode: %d\n", mode);
    }
    else
	return SQERR_NOTSUPPORTED;

    bytes = finfo->image[currentImage].w * finfo->image[currentImage].h * sizeof(RGBA);
    
    char type[25];
    strcpy(type, "RGB"); /* Usually image is in RGB format */

    finfo->images++;

    asprintf(&finfo->image[currentImage].dump, "%s\n%dx%d\n%d\n%s\n?COMPRESSION?\n%d\n",
	fmt_quickinfo(),
	finfo->image[currentImage].w,
	finfo->image[currentImage].h,
	finfo->image[currentImage].bpp,
	type,
	bytes);

    return SQERR_OK;
}

int fmt_next_pass(fmt_info *finfo)
{
    if(!finfo)
	return SQERR_NOTOK;

    if(!finfo->image)
	return SQERR_NOTOK;

    finfo = finfo;

    return SQERR_OK;
}

int fmt_read_scanline(fmt_info *finfo, RGBA *scan)
{
    memset(scan, 255, finfo->image[currentImage].w * sizeof(RGBA));

    return SQERR_OK;
}

int fmt_readimage(const char *file, RGBA **image, char **dump)
{
    FILE *m_fptr;
    int w, h, bpp;

    m_fptr = fopen(file, "rb");
				        
    if(!m_fptr)
        return SQERR_NOFILE;


    /* Do something like fmt_next() here */
    /* ... */

    w = 1;//width;
    h = 1;//height;
    bpp = 1;//bpp;

    int m_bytes = w * h * sizeof(RGBA);

    /*
	Dump has the following format: "%QUICK_INFO\n%WIDTH\n%HEIGHT\n
        %BPP\n%COLOR_TYPE\n%COMPRESSION\n%NUMBER_OF_IMAGES\n%TOTAL_BYTES_NEEDED"
    */
    asprintf(dump, "%s\n%d\n%d\n%d\n%s\n-\n%d\n%d\n",
	fmt_quickinfo(),
	w,
	h,
	bpp,
	"RGB",
	1,
	m_bytes);

    *image = (RGBA*)realloc(*image, m_bytes);
						
    if(!*image)
    {
        fprintf(stderr, "libSQ_read_psd: Image is null!\n");
        fclose(m_fptr);
        return SQERR_NOMEMORY;
    }

    memset(*image, 255, m_bytes);

    /*  reading ... */
    
    for(int h2 = 0;h2 < h;h2++)
    {
	RGBA 	*scan = *image + h2 * w;

	memset(scan, 255, w * sizeof(RGBA));
    }
    
    /* Do something like fmt_close() here */
    fclose(m_fptr);

    /* Everything OK */
    return SQERR_OK;
}

int fmt_close()
{
    fclose(fptr);

    return SQERR_OK;
}

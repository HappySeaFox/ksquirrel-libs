#!/bin/sh

name=$1
mkdir $name
cd $name

create_build()
{
cat << EOF > compile-c
#!/bin/sh

rm -f libSQ_read_$1.so
gcc -Wall -Werror -O2 -D__USE_GNU -fPIC -c read_$1.c
gcc -Wall -Werror -O2 -shared read_$1.o -o libSQ_read_$1.so
rm -f read_$1.o
EOF

cat << EOF > compile-c++
#!/bin/sh

rm -f libSQ_read_$1.so
g++ -Wall -Werror -O2 -fPIC -c read_$1.cpp
g++ -Wall -Werror -O2 -shared read_$1.o -o libSQ_read_$1.so
rm -f read_$1.o
EOF

chmod +x compile-c compile-c++
} # function

cat << EOF > Makefile.am
lib_LTLIBRARIES = libSQ_read_$name.la
libSQ_read_${name}_la_SOURCES = read_$name.cpp read_$name.h
libSQ_read_${name}_la_LIBDADD = 
EXTRA_DIST = read_$name.cpp read_$name.h
libSQ_read_$name_la_LDFLAGS = -release 1.0.0
EOF

cat << EOF > read_$name.h
/*  This file is part of KSquirrel's (http://ksquirrel.sf.net) libraries

    Copyright (c) 2004 Dmitry Baryshev <ksquirrel@tut.by>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation;
    either version 2 of the License, or (at your option) any later
    version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#ifndef KSQUIRREL_READ_IMAGE_$name
#define KSQUIRREL_READ_IMAGE_$name

#include "../defs.h"
#include "../err.h"

extern "C" {

const char*	fmt_version();
const char*	fmt_quickinfo();
const char*	fmt_filter();
const char*	fmt_mime();
const char*	fmt_pixmap();

int 	fmt_init(fmt_info *finfo, const char *file);
int	fmt_read_scanline(fmt_info *finfo, RGBA *scan);
int	fmt_readimage(const char*, RGBA **scan, char **dump);
int	fmt_close();

int    fmt_next(fmt_info *finfo);
int    fmt_next_pass(fmt_info *finfo);

}

#endif
EOF

cat << EOF > read_$name.cpp
/*  This file is part of KSquirrel's (http://ksquirrel.sf.net) libraries

    Copyright (c) 2004 Dmitry Baryshev <ksquirrel@tut.by>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation;
    either version 2 of the License, or (at your option) any later
    version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include "read_$name.h"

FILE *fptr;
int bytes, currentImage;

const char* fmt_version()
{
    return (const char*)"0.1";
}

const char* fmt_quickinfo()
{
    return (const char*)"";
}

const char* fmt_filter()
{
    return (const char*)"*.$name ";
}

const char* fmt_mime()
{
/*  QRegExp pattern  */
    return (const char*)"";
}

const char* fmt_pixmap()
{
    return (const char*)"";
}

int fmt_next(fmt_info *finfo)
{
    currentImage++;

    memset(&finfo->image[currentImage], 0, sizeof(fmt_image));
    
    /* Move to the next image here */


    /* Compute total bytes needed for the image */
    bytes = finfo->image[currentImage].w * finfo->image[currentImage].h * sizeof(RGBA);
    
    /* Determine image type (RGB, RGBA, YUV, etc.) */
    char type[25];
    strcpy(type, "RGB"); /* Usually image is in RGB format */

    /* Write dump */
    asprintf(&finfo->image[currentImage].dump, "%s\n%dx%d\n%d\n%s\n?COMPRESSION?\n%d\n",
	fmt_quickinfo(),
	finfo->image[currentImage].w,
	finfo->image[currentImage].h,
	finfo->image[currentImage].bpp,
	type,
	bytes);

    return SQERR_NOTOK;
}

int fmt_next_pass(fmt_info *finfo)
{
    if(!finfo)
	return SQERR_NOTOK;

    if(!finfo->image)
	return SQERR_NOTOK;

    finfo = finfo;

    return SQERR_OK;
}

int fmt_init(fmt_info *finfo, const char *file)
{
    if(!finfo)
        return SQERR_NOMEMORY;
	
    if(!finfo->image)
	return SQERR_NOMEMORY;

    fptr = fopen("file", "rb");

    if(!fptr)
        return SQERR_NOFILE;
	
    memset(finfo, 0, sizeof(fmt_info));
		
    finfo->passes = 1;

    currentImage = -1;

    return SQERR_OK;
}

int fmt_read_scanline(fmt_info *finfo, RGBA *scan)
{
    memset(scan, 255, finfo->image[currentImage].w * sizeof(RGBA));

    return SQERR_OK;
}

int fmt_readimage(const char *file, RGBA **image, char **dump)
{
    return SQERR_OK;
}

int fmt_close(fmt_info *finfo)
{
    fclose(fptr);

    return SQERR_OK;
}
EOF

if [ "$2" = "-build" ]; then create_build $name; else echo; fi

echo
echo "All done!"
echo

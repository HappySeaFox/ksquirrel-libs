#!/bin/sh

name=$1
mkdir $name
cd $name

create_build()
{
cat << EOF > compile-c
#!/bin/sh

rm -f libSQ_read_$1.so
gcc -Wall -Werror -O2 -D__USE_GNU -fPIC -c read_$1.c
gcc -Wall -Werror -O2 -shared read_$1.o -o libSQ_read_$1.so
rm -f read_$1.o
EOF

cat << EOF > compile-c++
#!/bin/sh

rm -f libSQ_read_$1.so
g++ -Wall -Werror -O2 -fPIC -c read_$1.cpp
g++ -Wall -Werror -O2 -shared read_$1.o -o libSQ_read_$1.so
rm -f read_$1.o
EOF

chmod +x compile-c compile-c++
} # function

cat << EOF > Makefile.am
INCLUDES = -I.. -I.
lib_LTLIBRARIES = libSQ_read_$name.la
libSQ_read_${name}_la_SOURCES = read_$name.cpp read_$name.h
libSQ_read_${name}_la_LIBDADD = 
EXTRA_DIST = read_$name.cpp read_$name.h
libSQ_read_${name}_la_LDFLAGS = -release 1.0.0
LIBS = 
EOF

cat << EOF > read_$name.h
/*  This file is part of ksquirrel-libs (http://ksquirrel.sf.net)

    Copyright (c) 2005 Dmitry Baryshev <ksquirrel@tut.by>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation;
    either version 2 of the License, or (at your option) any later
    version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#ifndef KSQUIRREL_READ_IMAGE_$name
#define KSQUIRREL_READ_IMAGE_$name

#include "defs.h"
#include "err.h"
#include "fio.h"

extern "C" {

const char*	fmt_version();
const char*	fmt_quickinfo();
const char*	fmt_filter();
const char*	fmt_mime();
const char*	fmt_pixmap();

int 	fmt_init(fmt_info *finfo, const char *file);
int	fmt_read_scanline(fmt_info *finfo, RGBA *scan);
int	fmt_readimage(const char*, RGBA **scan, char *dump);
void	fmt_close();

int    fmt_next(fmt_info *finfo);
int    fmt_next_pass(fmt_info *finfo);

}

#endif
EOF

cat << EOF > read_$name.cpp
/*  This file is part of ksquirrel-libs (http://ksquirrel.sf.net)

    Copyright (c) 2005 Dmitry Baryshev <ksquirrel@tut.by>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation;
    either version 2 of the License, or (at your option) any later
    version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <setjmp.h>

#include "read_$name.h"

FILE *fptr;
int bytes, currentImage;

const char* fmt_version()
{
    return (const char*)"0.1";
}

const char* fmt_quickinfo()
{
    return (const char*)"";
}

const char* fmt_filter()
{
    return (const char*)"*.$name ";
}

const char* fmt_mime()
{
/*  QRegExp pattern  */
    return (const char*)"";
}

const char* fmt_pixmap()
{
    return (const char*)"";
}

int fmt_init(fmt_info *finfo, const char *file)
{
    if(!finfo)
        return SQERR_NOMEMORY;
	
    fptr = fopen(file, "rb");

    if(!fptr)
        return SQERR_NOFILE;
	
    currentImage = -1;

    return SQERR_OK;
}

int fmt_next(fmt_info *finfo)
{
    currentImage++;

    if(!finfo)
        return SQERR_NOMEMORY;

    if(!finfo->image)
	return SQERR_NOMEMORY;

    memset(&finfo->image[currentImage], 0, sizeof(fmt_image));

    /* You can setup number of passes here, or later */
    finfo->image[currentImage].passes = 1;

    /* Move to the next image here */


    /* Compute total bytes needed for the image */
    bytes = finfo->image[currentImage].w * finfo->image[currentImage].h * sizeof(RGBA);
    
    /* Determine image type (RGB, RGBA, YUV, etc.) */
    char type[25];
    strcpy(type, "RGB"); /* Usually image is in RGB format */
    
    finfo->images++;

    /* Write dump */
    snprintf(finfo->image[currentImage].dump, sizeof(finfo->image[currentImage].dump)-1,

	"%s\n%dx%d\n%d\n%s\n?COMPRESSION?\n%d\n",

	fmt_quickinfo(),
	finfo->image[currentImage].w,
	finfo->image[currentImage].h,
	finfo->image[currentImage].bpp,
	type,
	bytes);

    return SQERR_OK;
}

int fmt_next_pass(fmt_info *)
{
    return SQERR_OK;
}

int fmt_read_scanline(fmt_info *finfo, RGBA *scan)
{
    memset(scan, 255, finfo->image[currentImage].w * sizeof(RGBA));

    return SQERR_OK;
}

int fmt_readimage(const char *file, RGBA **image, char *dump)
{
    FILE 	*m_fptr;
    int 	w, h, bpp;
    jmp_buf	jmp;

    m_fptr = fopen(file, "rb");
				        
    if(!m_fptr)
        return SQERR_NOFILE;

    if(setjmp(jmp))
    {
	fclose(m_fptr);
	return SQERR_BADFILE;
    }

    /* Do something like fmt_next() here */
    /* ... */

    w = width;
    h = height;
    bpp = bpp;

    int m_bytes = w * h * sizeof(RGBA);

    /*
	Dump has the following format: "%QUICK_INFO\n%WIDTH\n%HEIGHT\n
        %BPP\n%COLOR_TYPE\n%COMPRESSION\n%NUMBER_OF_IMAGES\n%TOTAL_BYTES_NEEDED"
    */
    sprintf(dump, "%s\n%d\n%d\n%d\n%s\n-\n%d\n%d\n",
	fmt_quickinfo(),
	w,
	h,
	bpp,
	"RGB",
	1,
	m_bytes);

    *image = (RGBA*)realloc(*image, m_bytes);
						
    if(!*image)
    {
        fprintf(stderr, "libSQ_read_$name: Image is null!\n");
	longjmp(jmp, 1);
    }

    memset(*image, 255, m_bytes);

    /*  reading ... */
    
    for(int h2 = 0;h2 < h;h2++)
    {
	RGBA 	*scan = *image + h2 * w;

    }
    
    /* Do something like fmt_close() here */
    fclose(m_fptr);

    /* Everything OK */
    return SQERR_OK;
}

void fmt_close()
{
    fclose(fptr);
}
EOF

if [ "$2" = "-build" ]; then create_build $name; else echo; fi

echo
echo "All done!"
echo
